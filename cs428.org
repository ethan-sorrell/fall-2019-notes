* Chapter 1: Overview
** The CIA Triad
- Confidentiality
  - Preserving intended restrictions on information access
- Integrity
  - Guarding against improper information modification or destruction
- Availability
  - Ensuring timely and reliable access to information
** Additional Security Concepts
- Authenticity
- Accountability
** Challenges
- Only one vulnerability needs to be found by attacker,
  defender must patch all vulnerabilities
** Categories of Vulnerabilities
- Corrupted (loss of integrity)
- Leaky (loss of confidentiality)
- Unavailable (loss of availability)
** Categories of Attacks
- Passive
  - attempt to learn or make use of information from the system that does not affect system resources
- Active
  - attempt to alter system resources or affect their operation
- Insider
  - initiated by an entity within the security perimeter
- Outsider
  - initiated by an entity outside of the security perimeter
** Security Functional Requirements
- Security technical measures
  - required to deal with access control problems
  - identification and authentication
  - system and communication protection
  - system and information integrity
- Management controls and procedures
  - awareness and training
  - audit and accountability
  - certification, acreditation and security assessments
* Chapter 2: Cryptographic Tools
** Cryptography vs. Security
- Theory vs Practice
- Tools vs. Applications
- etc
** Symmetric Encryption
- Also referred to as conventional encryption or single-key encryption
*** Two requirements for secure use:
- Strong encryption algorithm
- Sender and receiver must have obtained copies of the secret key in a secure fashion
** Attacking Symmetric Encryption
- Broadly divided into cryptanalytic and brute-force attacks
- Crypt analytic exploits weaknesses in the algorithm
- A more critical possibility:
  - Stealing the keys from memory or disk
** Table 2.1
|                              | DES | Triple DES |              AES |
|------------------------------+-----+------------+------------------|
| Plaintext block size (bits)  |  64 |         64 |              128 |
| Ciphertext block size (bits) |  64 |         64 |              128 |
| Key size (bits)              |  56 | 112 or 168 | 128, 192, or 256 |
|------------------------------+-----+------------+------------------|
** Data Encryption Standard (DES)
- Most widely used encryption scheme
- Uses 64 bit plaintext block and 56 bit key to produce 64 bit ciphertext block
- Use of 56-bit key is strength concern:
  - EEF announced in July 1998 it had broken a DES encryption
- See diagram in slides
*** Triple DES (3DES)
- Repeat DES algorithm three times
- First standardized for use in finance in ANSI standard X9.17 in 1985
- Sluggish performance
** Advanced Encryption Standard (AES)
- NIST called for proposals for a new AES in 1997
- Selected Rijndael in November 2001
- See diagram in slides
** Practical Security Issues
- Typically encryption is applied to a unit  of data larger than e.g. a single 64-bit block
- Electronic codebook (ECB) mode is the simplest approach to multiple-block encryption
  - Each block is encrypted using the same key
  - Regularities in the plaintext may be exploitable
- Modes of operation
  - Alternative technique developed to increase security for symmetric block encryption of large sequences
  - Overcomes the weaknesses of ECB
** Block Ciphers
- Processes the input one block of elements at a time
- Produces separate output block for each input block
- Can reuse keys
- More common (than stream cipher?)
** Stream Ciphers
- Processes the input elements continuously
- Primary advantage is that this form of cipher is faster and uses less code
- Pseudorandom stream is one that is unpredictable without knowledge of the input key
** Public-Key Encryption Structure
- Asymmetric
  - Uses two separate keys
  - Public key and private key
  - Some form of protocol is needed for distribution
- See slides for diagram
- Each user has a public and private key
- Use intended receiver's public key to encrypt, They use their private key to decrypt
- Or the opposite
- e.g. PGP is Public Key Encryption
** RSA
- to encrypt a message M, the sender:
  - obtains public key of recipient: {e, n}
  - computes: C = M^e mod n where 0 <= M < n
- to decrypt the ciphertext C, the owner:
  - uses their private key: {d, n}
  - computes: M = C^d mod n
** Requirements for Public-Key Cryptosystems
- Computationally easy to:
  - create key pairs
  - encrypt message given public key
  - decrypt ciphertext knowing private key
- Computationally infeasible to:
  - recover original message without private key
  - determine private key from public key
- Also useful if either key can be used for either role
** Asymmetric Encryption Algorithms
- RSA (Rivest, Shamir, Adleman)
  - Developed in 1977
  - Most widely accepted and implemented approach to public-key encryption
  - Block cipher in which the plaintext and ciphertext are integers between 0 and n-1
- Diffie-Hellman key exchange
  - Enables two users to securely reach agreement about a shared secret that can be used as a secret key for subsequent symmetric encryption of messages
  - Limited to the exchange of keys
- Digital Signature Standard (DSS)
  - Provides only a digital signature function with SHA-1
  - Cannot be used for encryption or key exchange
- Elliptic Curve Cryptography (ECC)
  - Security like RSA, but with much smaller keys
** Table 2.3
| Algorithm      | Digital Signature | Symmetric Key Distribution | Encryption of Secret Keys |
|----------------+-------------------+----------------------------+---------------------------|
| RSA            | Yes               | Yes                        | Yes                       |
| Diffie-Hellman | No                | Yes                        | No                        |
| DSS            | Yes               | No                         | No                        |
| Elliptic Curve | Yes               | Yes                        | Yes                       |
** Symmetric vs Public Key
- Conventional Encryption
** Message Authentication
** Hash Function Requirements
- Can be applied to any size block of data
- Produces a fixed-length output
- Relatively easy to compute for any input
- One way or pre-image resistant (not reversible to get input)
- Second pre-image resistant or weak collision resistant
  - Computationally infeasible to find input which will hash to the same value as given input
- Collision resistant or strong collision resistance
  - Computationally infeasible to find any pair of inputs that will hash to the same value
Note the distinction between weak collision resistant and strong collision resistant 
** Security of Hash Functions
- SHA most widely used hash algorithm
*** Additional secure hash function applications:
- Password
  - Hash of a password is stored rather than password itself
- Intrusion detection
  - Store H(F) for each file on a system and secure the hash values
  - Now possible to detect manipulation by recomputing hash values
*** Two approaches to attacking a secure hash function
- Cryptanalysis
- Brute-force
** Digital Signatures
- Think PGP
** Digital Envelopes
- Rather than using public key to encrypt message, encrypt a symmetric key using public key, and send message encrypted with this symmetric key
- This is useful as symmetric key encryption is quicker
** Random Numbers Uses
- Keys for public-key algorithms
- Stream key for symmetric stream cipher
- Symmetric key for use in e.g. creating a digital envelope
- Handshaking to prevent replay attack
- Session key
** Practical Application: Encryption of Stored Data
- Common to encrypt transmitted data
- Much less common to encrypt stored data
* Chapter 10: Buffer Overflow
** Buffer Overflow
- A very common attack mechanism
- Known prevention techniques
- A buffer overflow, also known as buffer overrun defined:
  - A condition at an interface under which more input can be placed into a buffer than the capacity allocated, overwriting other information. Exploited to crash a system, or insert carefully crafted code to gain control of the system.
** Buffer Overflow Basics
- A process attempts to store data beyond the limits of a fixed-sized buffer
- Overwrites adjacent memory locations
- Buffer could be located on the stack, in the heap, or in the data section of the process
** Programs and Processes
| Kernel Code and Data  |
| Stack                 |
| Spare Memory          |
| Heap                  |
| Global Data           |
| Program Machine Code  |
| Process Control Block |
** Buffer Overflow Attacks
- The exploit a buffer overflow an attacker needs:
  - To identify a buffer overflow vulnerability in some program that can be triggered using data under the attacker's control
  - To understand how that buffer is stored in memory and determine potential for corruption
- Identifying vulnerable programs can be done by:
  - Inspection of program source
  - Tracing the execution of programs as they process over-sized input
  - Using tools such as fuzzing to automatically identify potential vulnerabilities
** Programming Language History
- At the machine level, data manipulated by machine instructions much be stored in either the processor's registers or in memory
- Assembly language program is responsible for the correct interpretation of any saved data value
** Stack Buffer Overflows 
- Occur when overflown buffer is located on stack
  - Also referred to as stack smashing
- Still being widely exploited
- Stack frame
  - Stores return address when one function calls another function
  - Also needs location to save passed parameters and possible save register values
